# Copyright (c) 2013 Shotgun Software Inc.
#
# CONFIDENTIAL AND PROPRIETARY
#
# This work is provided "AS IS" and subject to the Shotgun Pipeline Toolkit
# Source Code License included in this distribution package. See LICENSE.
# By accessing, using, copying or modifying this work you indicate your
# agreement to the Shotgun Pipeline Toolkit Source Code License. All rights
# not expressly granted therein are reserved by Shotgun Software Inc.

import os
import nuke
from tank import Hook
import sgtk

class BreakdownSceneOperations(Hook):
    """
    Breakdown operations for Nuke.

    This implementation handles detection of Nuke read nodes,
    geometry nodes and camera nodes.
    """

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.

        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:

        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.

        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        reads = []
        try:
            nuke_path = nuke.toNode('Published Data')
            path = nuke_path.knob('text').value().replace("/", os.path.sep)
            node_name = nuke_path.name()
            reads.append({"node": node_name, "type": "Nuke Script", "path": path})
        except:
            self.parent.engine.log_debug("Published Node not found")


        # first let's look at the read nodes
        for node in nuke.allNodes("Read"):

            node_name = node.name()

            # note! We are getting the "abstract path", so contains
            # %04d and %V rather than actual values.
            path = node.knob('file').value().replace("/", os.path.sep)
            reads.append({"node": node_name, "type": "Read", "path": path})
        # #
        # # then the read geometry nodes
        # for node in nuke.allNodes("ReadGeo2"):
        #      node_name = node.name()
        #
        #      path = node.knob('file').value().replace("/", os.path.sep)
        #      reads.append( {"node": node_name, "type": "ReadGeo2", "path": path})
        #
        # # then the read camera nodes
        # for node in nuke.allNodes("Camera2"):
        #      node_name = node.name()
        #
        #      path = node.knob('file').value().replace("/", os.path.sep)
        #      reads.append( {"node": node_name, "type": "Camera2", "path": path})
        #
        #
        return reads


    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.

        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.

        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the path that each node should be updated *to* rather than the current path.
        """

        # Get the Published Nuke Script's new file path
        new_script_path = None
        node_script_type = ['Nuke Script']
        for i in items:
            script_type = i['type']

            if script_type in node_script_type:
                new_script_path = i['path'].replace("/", os.path.sep)

        engine = self.parent.engine

        if new_script_path:
            engine.log_debug("Updating Published Script")
            self._import_script(new_script_path)

        node_type_list = ["Read", "ReadGeo2", "Camera2"]

        for i in items:
            node_name = i["node"]
            node_type = i["type"]
            new_path = i["path"]

            if node_type in node_type_list:
                engine.log_debug("Node %s: Updating to version %s" % (node_name, new_path))
                node = nuke.toNode(node_name)
                # make sure slashes are handled correctly - always forward
                new_path = new_path.replace(os.path.sep, '/')
                node.knob("file").setValue(new_path)
                self.color_updated_read_node(node)

    # #
    # ##############################################################################################################
    # # helper methods which can be subclassed in custom hooks to fine tune the behavior of things
    #



    def _import_script(self, new_script_path):
        """
        Import contents of the given file into the scene.

        :param path: Path to file.
        :param sg_publish_data: Shotgun data dictionary with all the standard publish fields.
        """

        # first we look at the current read nodes in the scene (they've been updated to their latest version already)
        preloaded_nodes = nuke.allNodes('Read')


        # We import the new nodes into the scene
        # if not os.path.exists(new_path):
        #     raise Exception("File not found on disk - '%s'" % new_path)

        nuke.nodePaste(new_script_path)
        node = nuke.toNode('Published Data')
        node['text'].setValue(new_script_path)

        # Compare the new nodes with the old ones and delete the duplicates
        new_nodes = [item for item in nuke.allNodes('Read') if item not in preloaded_nodes]

        # Initialise the tank
        tk = sgtk.sgtk_from_path(new_script_path)

        # Get the maya render template
        maya_render_template = tk.templates["maya_shot_render"]

        cleanup_list = []
        # Iterate through all the node
        for new_node in new_nodes:
            new_path = new_node['file'].value()
            # Is it a published render
            if maya_render_template.validate(new_path):
                new_fields = maya_render_template.get_fields(new_path)
                # Iterate through all the pre loaded node
                for old_node in preloaded_nodes:
                    old_path = old_node['file'].value()
                    # Is it a published node
                    if maya_render_template.validate(old_path):
                        old_fields = maya_render_template.get_fields(old_path)
                        # Compare the fields
                        if (new_fields['Shot'] == old_fields['Shot']
                            and new_fields['render_layer'] == old_fields['render_layer']
                            and new_fields['version'] > old_fields['version']):
                            old_node["file"].setValue(new_path)
                            cleanup_list.append(new_node)
                            self.color_updated_read_node(old_node)

        #Delete any redundents nodes
        for node in list(set(cleanup_list)):
            nuke.delete(node )


    def color_updated_read_node(self, node):
        r = 222
        g = 60
        b = 222
        hexColor = int('%02x%02x%02x%02x' % (r, g, b, 1), 16)
        node['tile_color'].setValue(hexColor)

